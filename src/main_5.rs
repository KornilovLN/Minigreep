//--- нам понадобится функция std::env::args из стандартной библиотеки
use std::env;
//--- Для работы с файлом
use std::fs;
//--- Нужно для выхода из программы с ненулевым сообщением системе
use std::process;

use std::error::Error;


//--- Мы сделали два изменения в теле функции new : 
//--- вместо вызова panic! , когда поль­зователь не передает достаточного числа 
//--- аргументов, мы теперь возвращаем значение Err , 
//--- и мы завернули в Ok значение, возвращаемое из структуры Config . 
//--- Эти изменения подчиняют функцию новой сигнатуре типа.
//--- Возвращение значения Err из функции Config::new 
//--- позволяет функции main обрабатывать значение Result , 
//--- возвращаемое из функции new , и лучше завершать работу в случае ошибки.
fn main() {
	//--- вызываем функцию env::args и сразу же при­меняем функцию collect
	//--- и привязываем коллекцию к неизменяемой переменной args 
	//--- типа Vec<string> 
	let args: Vec<String> = env::args().collect();
	println!("{:?}", args);
	
	//--- Создадим экземпляр Config и сохраним аргументы 
	//--- клонировав их к config полям структуры
	//--- Ис­пользование метода unwrap_or_else позволяет определять настраиваемую
	//--- обработку ошибок без вызова макрокоманды panic! . 
	//--- Если Result равен значению Ok, то поведение этого метода аналогично 
	//--- методу unwrap : он возвращает внутреннее значение, обернутое Ok. 
	//--- Однако если это значение равно Err, то метод вызывает код в замыкании,
	//--- то есть анонимную функцию, которую мы определяем и пере­даем в качестве
	//--- аргумента в методе unwrap_or_else
	let config = Config::new(&args).unwrap_or_else(|err| {
		println!("Проблема при разборе аргументов: {}", err);
		process::exit(1);
	});
	config.out();
	
	//--- Заменяем run(config);
	//--- используем if let вместо метода unwrap_or_else для проверки, 
	//--- что функция run возвращает значение Err , 
	//--- и вызываем process::exit(1) , если это так
	//--- Функция run не возвращает значение, которое требуется развернуть 
	//--- (методом unwrap ) так, как это делает функция Config::new , 
	//--- которая возвращает экземпляр структуры Config . 
	//--- Поскольку run в случае успеха возвращает () , 
	//--- нас интересует только обнаружение ошибки, поэтому нам не нужно 
	//--- выполнять метод unwrap_or_else , чтобы вернуть развернутое значение, 
	//--- потому что оно будет исключительно ()
	if let Err(e) = run(config) {
		println!("Ошибка в приложении: {}", e);

		process::exit(1);
	}	
	
}

//--- Решаем использовать структуру вместо кортежа
struct Config {
	prg: String,
	query: String,
	filename: String,
}

//--- Имплементация функции-конструктора для структуры Config
//--- Новый парсер вх аргументов заполняет структуру Config
//--- clone() необходим для полного копирования, а не только передачи ссылки
//--- с проверкой на ошибку количества аргументов
impl Config {
	//--- Функция new теперь возвращает Result с экземпляром структуры 
	//--- Config в случае успеха и &'static str в случае ошибки
	fn new(args: &[String]) -> Result<Config, &'static str> {
	    //--- Добавление проверки числа аргументов (должно быть 3)
	    if args.len() < 3 {
			return Err("недостаточно аргументов");
			
		}

		let prg = args[0].clone();
		let query = args[1].clone();
		let filename = args[2].clone();
	
	    //--- (result == ok) будет выдан методу unwrap_or_else()
	    //--- в вызывающую функцию main() вместе со структурой config
		Ok(Config { prg, query, filename })
	}
}

impl Config {
	//--- out() использует поля экземпляра своей структуры Config, 
	//--- поэтому пишем &self,
	//--- а знак ссылки & не дает завладеть экземпляром структуры 
	fn out(&self) {
		println!("Программа \t{}", self.prg);
		println!("Поиска  \t{}", self.query);
		println!("В файле \t{}", self.filename);
	}
}

//--- Тут Box<dyn Error> означает, что функция будет возвращать тип, 
//--- который реализует типаж Error
//--- Вместо того чтобы вызывать panic! в случае ошибки, опертор ? 
//--- будет возвращать значение ошибки из текущей функции, 
//--- чтобы вызываю­щий код обработал ее
//--- функция run теперь возвращает значение Ok в случае успеха
fn run(config: Config) -> Result<(), Box<dyn Error>> {
	let contents = fs::read_to_string(config.filename)?;
	
	println!("\nС текстом:\n{}", contents);

    //--- функция ничего не возвращает, а только говорит об успешной работе
	Ok(())
}
/*
fn run(config: Config) {
	let contents = fs::read_to_string(config.filename)
		.expect("Что-то пошло не так при чтении файла");
		
	println!("С текстом:\n{}", contents);	
}
*/	
